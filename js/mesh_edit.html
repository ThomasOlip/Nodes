<!DOCTYPE html>
<html lang="en">
<head>
    <title>Visual Fruit Nodes</title>
    <script src="https://pixijs.download/v6.5.8/pixi.min.js"></script>
    <style>
    </style>
</head>
<body>
<script>
    function loadJSON(callback) {
        const xhr = new XMLHttpRequest();
        xhr.overrideMimeType("application/json");
        xhr.open('GET', 'model/meshData.json', true);
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                callback(JSON.parse(xhr.responseText));
            }
        };
        xhr.send(null);
    }

    loadJSON(function(data) {
        const app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: 0x575757,
            antialias: true,
            resolution: window.devicePixelRatio || 1,
        });

        document.body.appendChild(app.view);

        class VertexButton extends PIXI.Graphics {
            constructor(vert) {
                super();
                this.vert = vert;
                this.id = vert.id;
                this.beginFill(0xFF7900);
                this.drawCircle(0, 0, 2.5);
                this.endFill();
                this.x = vert.x;
                this.y = vert.y;
            }

            update() {
                this.vert.x = this.x;
                this.vert.y = this.y;
            }
        }

        class EdgeButton extends PIXI.Graphics {
            constructor(edge, vertFrom, vertTo) {
                super();
                this.id = edge.id;
                this.vertFrom = vertFrom;
                this.vertTo = vertTo;
                this.lineStyle(1, 0x000000);
                this.moveTo(vertFrom.x, vertFrom.y);
                this.lineTo(vertTo.x, vertTo.y);
            }

            update() {
                this.clear();
                this.lineStyle(1, 0x000000);
                this.moveTo(this.vertFrom.x, this.vertFrom.y);
                this.lineTo(this.vertTo.x, this.vertTo.y);
            }
        }

        function createMesh(meshData) {
            const vertices = meshData.vertices;
            const edges = meshData.edges;
            const polygon = new PIXI.Graphics();
            const blurFilter = new PIXI.filters.BlurFilter();
            blurFilter.blur = meshData.blurAmount;
            polygon.filters = [blurFilter];

            app.stage.addChild(polygon);

            const buttonContainer = new PIXI.Container();
            app.stage.addChild(buttonContainer);

            const edgeButtons = [];
            const vertButtons = [];

            for (let i = 0; i < edges.length; i++) {
                const ebutton = new EdgeButton(edges[i], vertices[edges[i].from], vertices[edges[i].to]);
                edgeButtons.push(ebutton);
                buttonContainer.addChild(ebutton);
            }

            for (let i = 0; i < vertices.length; i++) {
                const vbutton = new VertexButton(vertices[i]);
                vertButtons.push(vbutton);
                vbutton.interactive = true;
                vbutton.cursor = 'pointer';

                vbutton
                    .on('pointerdown', onDragStart)
                    .on('pointerup', onDragEnd)
                    .on('pointerupoutside', onDragEnd)
                    .on('pointermove', onDragMove);

                buttonContainer.addChild(vbutton);
            }

            let dragging = null;
            let dragOffset = null;

            function onDragStart(event) {
                dragging = this;
                dragOffset = event.data.getLocalPosition(this.parent);
                dragOffset.x -= this.x;
                dragOffset.y -= this.y;
                this.beginFill(0xffffff);
                this.drawCircle(0, 0, 2.5);
                this.endFill();
            }

            function onDragEnd() {
                if (dragging) {
                    this.beginFill(0xFF7900);
                    this.drawCircle(0, 0, 2.5);
                    this.endFill();
                    dragging = null;
                }
                dragOffset = null;
            }

            function onDragMove(event) {
                if (dragging) {
                    const newPosition = event.data.getLocalPosition(dragging.parent);
                    dragging.x = newPosition.x - dragOffset.x;
                    dragging.y = newPosition.y - dragOffset.y;
                    vertButtons.forEach((vertButton) => vertButton.update());
                    edgeButtons.forEach((edgeButton) => edgeButton.update());
                    updatePolygon();
                }
            }

            function updatePolygon() {
                polygon.clear();
                polygon.beginFill(meshData.backgroundColor);
                polygon.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    polygon.lineTo(vertices[i].x, vertices[i].y);
                }
                polygon.closePath();
                polygon.endFill();
            }

            updatePolygon();
        }

        for (let i = 0; i < data.meshes.length; i++) {
            createMesh(data.meshes[i]);
        }

        const slider = document.createElement("input");
        slider.type = "range";
        slider.min = "0";
        slider.max = "20";
        slider.value = 5;
        slider.style.position = "absolute";
        slider.style.top = "10px";
        slider.style.left = "10px";
        document.body.appendChild(slider);

        slider.addEventListener("input", function () {
            const blurValue = parseFloat(slider.value);
            app.stage.children.forEach((mesh) => {
                if (mesh.filters && mesh.filters[0] instanceof PIXI.filters.BlurFilter) {
                    mesh.filters[0].blur = blurValue;
                }
            });
        });

        app.ticker.add(() => {});
    });
</script>
</body>
</html>
